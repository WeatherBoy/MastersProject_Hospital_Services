\section{Analysis}
\subsection{Identifying the Problem}
A good part of this project was dedicated merely to identifying what kind of problem the scheduling task posed. While working on the digital taskboard, this issue used up all of our idle "brain bandwidth". We spent the entire first month pondering commonly accepted AI optimisation techniques, such as the GA scheme. However, we kept running into dead ends. Namely, it seemed incredibly difficult to construct a suitable objective function that could teach such optimisation techniques, the underlying rules adhering naturally to the problem. After some time, it felt like designing a black box to learn the rules we already knew rather than employing them to find a solution. Thus, we came to the conclusion that we had, in all likelihood, gone about this problem in the wrong manner. As such, we had no other option but to do some research.

\subsubsection*{The Scheduling rabbit hole}
If the reader, like us, isn't very well-versed in schedule planning and the field of Operations Research~\cite{Wiki-Operations-Research}, they might also had been lured into the \emph{Scheduling}~\cite{Wiki-Scheduling-computing, Wiki-Optimal-job-scheduling, Wiki-Job-shop-scheduling} rabbit hole. Scheduling is a discipline that the vast majority of us enjoy on a regular basis, as it is used predominantly in CPUs. However, it is an entirely different algorithmic discipline for assigning jobs to machines. In this case, each job has a runtime, and sometimes the runtime varies based on the machine. At first, we thought this might just be an abstraction that we could still apply to our problem, but unfortunately, it isn't so simple. Notice that 'Scheduling', as just described, is a discipline within computer science and differs from our problem, which we elected to call 'the scheduling task'.
\\
One might think of the scheduling task as a mosaic of \(i \times j\) squares in a grid, where each square can be one of \(n\) different colours. We have \(m\) stacks of tiles that can assume all \(n\) colours, but each is a distinct shape. However, we can't change the colours of the tiles we have, and for a tile to fit onto the mosaic, it must match the colour of the corresponding square. The contractor has told us that we can't have more than one of each shape for each row, or it will ruin the 'synergy' (or whatever). We want to see whether we can lay the entire mosaic using no more than the tiles we have at our disposal. However, there might be more constraints; for example, the contractor might not like to have more than two of the same shape adjacent to each other in a column.
\begin{figure}[H]
    \centering
    \begin{subfigure}[t]{0.73\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/Analysis/BSAT-illustrated01.png}
        \subcaption*{An example mosaic in a grid (right) with available tiles (left).}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{0.225\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/Analysis/BSAT-illustrated02.png}
        \subcaption*{Succesfully laid mosaic.}
    \end{subfigure}
    \caption{Illustration of the scheduling task}
    \label{fig:the-scheduling-task-illustrated}
\end{figure}
On the other hand, we could think of Scheduling as having the weirdest mosaic ever. The contractor wants \(n\) rows; it doesn't matter what colours they have. The goal is to place our tiles in such a manner that the row which is furthest from the left wall is as close to the left wall as possible. However, we have to place all of our tiles. But they are annoying, magical tiles that change length according to which row we place them in.
\begin{figure}[H]
    \centering
    \begin{subfigure}[t]{0.715\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/Analysis/Scheduling-illustrated01.png}
        \subcaption*{An example weird-mosaic (right) with available magical tiles (left).}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{0.25\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/Analysis/Scheduling-illustrated02.png}
        \subcaption*{Succesfully laid weird-mosaic. The orange dotted line indicates the length of the longest row (from the left wall).}
    \end{subfigure}
    \caption{Illustration of Scheduling}
    \label{fig:scheduling-illustrated}
\end{figure}
The scheduling task and Scheduling, as illustated\footnote{We would like to apologise for these two illustrations being, by no means, colourblind-friendly. We hope that the description will suffice instead.} in \autoref{fig:the-scheduling-task-illustrated} and \autoref{fig:scheduling-illustrated} respectively\footnote{We want to state very explicitly that we in no way claim this is the optimal solution to the Scheduling problem we presented; it is merely meant as an illustration.}, are clearly related. They might even be cousins. But they could never swap social IDs for a month without anybody noticing.

\subsubsection*{From Assignment Problem to Binary ILP to BSAT}
After a little more research, we found out that, what we had na\"ively translated from Danish as, \emph{scheduling} seemed to be modelled by the \textbf{Assignment Problem}~\cite{Wiki-assignment-prob}. The Assignment Problem can be defined as the following: Given \(N\) agents and \(N\) tasks, where the cost of assigning agent \(i\) to task \(j\) is \(c_{ij}\), each agent must be assigned one and only one unique task. Any agent can be assigned to any task and the goal is to find an assignment which minimises the total cost of all assignments,
\begin{equation*}
    \min \sum_{i}^N \sum_{j}^N c_{ij} \cdot x_{ij},
\end{equation*}
where \(x_{ij}\) is \(1\) if agent \(i\) is assigned to task \(j\), and \(0\) otherwise.
\\
This looked promising. There are algorithmic solutions with polynomial runtimes, and for all purposes, the costs can be modelled as identical. There is the issue, as we mentioned in Methodology (see \autoref{sec:scheduling-assistant}), that for \(N\) tasks and \(M\) agents, we usually have \(M \ll N\). However, we deemed this could be alleviated by solving each day individually. Then, if there was a day with more agents than tasks, we could simply substitute them with dummy tasks, which we could remove from our final solution. This would obviously add the \(T\) coefficient to a polynomial runtime, but it might still be faster than exponential for problems with many variables. It quickly became apparent, though, that for constraints posed by tasks such as the "Rygvagt" (see \autoref{sec:translating-constraints}), the solution would be infeasible at worst or, at best, non-polynomial.
\\
\\
However, we had garnered from The Assignment Problem that it could be written up as a \textbf{Linear Program}\cite{OR-Intro-Book} (LP). Our problem, the scheduling task, would be a case of a Binary Integer Linear Program (Binary ILP). This is because all of our decision variables are boolean; either an agent is assigned to a given task, or they are not.
Now, a binary ILP takes the form\cite{Integer-Programming-Book} 
\begin{equation}\label{eq:binary-ILP}
    \begin{aligned}
    \max \quad &\sum_{i = 1}^m \sum_{j = 1}^n c_{ij} \cdot x_{ij}
    \\
    \text{subject to} \quad &\sum_{j = 1}^n a_{ij} \cdot x_{ij} \leq b \qquad &\text{for} \quad i = 1, \hdots, m
    \\
    &\sum_{i = 1}^m x_{ij} \leq 1 \qquad &\text{for} \quad j = 1, \hdots, n
    \\
    \text{for} \quad &x \in \{0, 1\}^{m \times n},
    \end{aligned}
\end{equation}
where \(x\) is the binary decision variable, \(c_{ij}\) is the value, or cost, connected with making the decision represented by \( (i,j) \), \( a_{ij} \) is the penalty incurred for \( (i,j) \) and finally \(b\) is an upper bound on our cumulated penalty.
\\
For the small subproblem we worked on, we didn't have any non-linear constraints. Therefore, there is no technical reason preventing us from writing up our problem as presented in \autoref{eq:binary-ILP} and solving it using OR. But looking at OR led us to CP, and the formulation presented in \autoref{eq:binary-ILP} gives way to a Boolean Satisfiability Problem (BSAT), which is a subfield of CP. We can attempt to solve a BSAT using a satisfiability (SAT) solver.
\\
There are many advantages to using the BSAT formulation over the Binary ILP. For one, OR is still inherently an optimisation technique that solves problems in the same ballpark as Scheduling and The Assignment Problem. It isn't designed for this kind of problem, where we aren't interested in a solution that is \(99.998\%\) optimal, but rather where we first and foremost need a valid solution, optimisation second. As such, formulating the problem is a tedious endeavour. It grows wildly as a function of variables and constraints, and while the same can be said for the BSAT formulation, SAT solvers are built for this; they prune the search space, eliminating redundancy while seeking valid solutions. Additionally, as shown in \autoref{sec:translating-constraints}, modern libraries enabling SAT solvers, such as Google's OR-Tools, allow for straightforward handling of more complex constraints, which would be a nightmare to define for a Binary ILP.
\\
\\
As a last remark on the technical implementation aspect, we will quickly address the running time. As exemplified in \autoref{eq:decision-variable-form}, we will have a decision variable for each agent \(a \in [0, M]\), for each day \(i \in [0, T]\), for each task \(j \in [0, N]\). This is a nice representation, but a better and more straightforward definition is that we have a sum of \(N\) tasks over all \(T\) days. That way, we can readily define the total number of decision variables in our boolean formula as \(M \cdot N\) without having to deal with having an unequal amount of tasks for each respective day. As we have stated many times, boolean satisfiability is NP-complete. Therefore, we ultimately end up with a running time of \(2^{M \cdot N}\).
\\
\\
As for The Automated Schedule Validator, as aforementioned, we are convinced that it is technically feasible. Additionally, it would seemingly fit right in with the rest of the suite of disconnected software applications; as such, it seems viable. However, we cannot help but question whether it would be a good solution or if we would just be another in a long line of software implementations that had insisted they keep on their floaties - rather than ever letting them try to swim on their own.