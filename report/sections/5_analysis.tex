\section{Analysis}
A good part of this project was dedicated merely to identifying what kind of problem the scheduling task posed. While working on the digital taskboard, this issue used up all of our idle "brain bandwidth". We spent the entire first month pondering commonly accepted AI optimisation techniques, such as the GA scheme. However, we kept running into dead ends. Namely, it seemed incredibly difficult to construct a suitable objective function that could teach such optimisation techniques, the underlying rules adhering naturally to the problem. After some time, it felt like designing a black box to learn the rules we already knew rather than employing them to find a solution. Thus, we came to the conclusion that we had, in all likelihood, gone about this problem in the wrong manner. As such, we had no other option but to do some research.
\\
If the reader, like us, isn't very well-versed in schedule planning and the field of Operations Research~\cite{Wiki-Operations-Research}, they might also had been lured into the \emph{Scheduling}~\cite{Wiki-Scheduling-computing, Wiki-Optimal-job-scheduling, Wiki-Job-shop-scheduling} rabbit hole. Scheduling is a discipline that the vast majority of us enjoy on a regular basis, as it is used predominantly in CPUs. However, it is an entirely different algorithmic discipline for assigning jobs to machines. In this case, each job has a runtime, and sometimes the runtime varies based on the machine. At first, we thought this might just be an abstraction that we could still apply to our problem, but unfortunately, it isn't so simple. Notice that 'Scheduling', as just described, is a discipline within computer science and differs from our problem, which we elected to call 'the scheduling task'.
\\
One might think of the scheduling task as a mosaic of \(i \times j\) squares in a grid, where each square can be one of \(n\) different colours. We have \(m\) stacks of tiles that can assume all \(n\) colours, but each is a distinct shape. However, we can't change the colours of the tiles we have, and for a tile to fit onto the mosaic, it must match the colour of the corresponding square. The contractor has told us that we can't have more than one of each shape for each row, or it will ruin the 'synergy' (or whatever). We want to see whether we can lay the entire mosaic using no more than the tiles we have at our disposal. However, there might be more constraints; for example, the contractor might not like to have more than two of the same shape adjacent to each other in a column.
\begin{figure}[H]
    \centering
    \begin{subfigure}[t]{0.73\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/Analysis/BSAT-illustrated01.png}
        \subcaption*{An example mosaic in a grid (right) with available tiles (left).}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{0.225\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/Analysis/BSAT-illustrated02.png}
        \subcaption*{Succesfully laid mosaic.}
    \end{subfigure}
    \caption{Illustration of the scheduling task}
    \label{fig:the-scheduling-task-illustrated}
\end{figure}
On the other hand, we could think of Scheduling as having the weirdest mosaic ever. The contractor wants \(n\) rows; it doesn't matter what colours they have. The goal is to place our tiles in such a manner that the row which is furthest from the left wall is as close to the left wall as possible. However, we have to place all of our tiles. But they are annoying, magical tiles that change length according to which row we place them in.
\begin{figure}[H]
    \centering
    \begin{subfigure}[t]{0.715\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/Analysis/Scheduling-illustrated01.png}
        \subcaption*{An example weird-mosaic (right) with available magical tiles (left).}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{0.25\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/Analysis/Scheduling-illustrated02.png}
        \subcaption*{Succesfully laid weird-mosaic. The orange dotted line indicates the length of the longest row (from the left wall).}
    \end{subfigure}
    \caption{Illustration of Scheduling}
    \label{fig:scheduling-illustrated}
\end{figure}
The scheduling task and Scheduling, as illustated\footnote{We would like to apologise for these two illustrations being, by no means, colourblind-friendly. We hope that the description will suffice instead.} in \autoref{fig:the-scheduling-task-illustrated} and \autoref{fig:scheduling-illustrated} respectively\footnote{We want to state very explicitly that we in no way claim this is the optimal solution to the Scheduling problem we presented; it is merely meant as an illustration.}, are clearly related. They might even be cousins. But they could never swap social IDs for a month without anybody noticing.
\\
\\
After a little more research, we found out that, what we had na\"ively translated from Danish as, \emph{scheduling} seemed to be modelled by the \textbf{Assignment Problem}~\cite{Wiki-assignment-prob}. The Assignment Problem can be defined as the following: Given \(N\) agents and \(N\) tasks, where the cost of assigning agent \(i\) to task \(j\) is \(c_{ij}\), each agent must be assigned one and only one unique task. Any agent can be assigned to any task and the goal is to find an assignment which minimises the total cost of all assignments,
\begin{equation*}
    \min \sum_{i}^N \sum_{j}^N c_{ij} \cdot x_{ij},
\end{equation*}
where \(x_{ij}\) is \(1\) if agent \(i\) is assigned to task \(j\), and \(0\) otherwise.
\\
This looked promising. There are algorithmic solutions with polynomial runtimes and for all purposes, the costs could be modelled as identical. There is the issue, as we mentioned in Methodology (see \autoref{sec:scheduling-assistant}), that for \(N\) tasks and \(M\) agents, we usually have \(M \ll N\). However, we deemed this could be alleviated by solving each day individually. Then, if there was a day with more agents than tasks, we could simply substitute them with dummy tasks, which we could remove from our final solution. This would obviously add the \(T\) coefficient to a polynomial runtime, but it might still be faster than exponential for problems with many variables. It quickly became apparent, though, that for constraints posed by tasks such as the "Rygvagt" (see \autoref{sec:translating-constraints}), the solution would be infeasible at worst or, at best, non-polynomial.
\\
\\
The scheduling task is a case of the \textbf{Generalised Assignment Problem}\cite{Wiki-general-assignment-prob}, which can ultimately be expressed as a \textbf{Linear Program}\cite{Wiki-linear-programming}, specifically, a \textbf{Binary Integer Program}.

However, in order to arrive at CP, we will first argue, without a complete theoretical deep dive, that the Generalised Assignment Problem can be reformulated into the binary case of an integer linear problem (ILP). A binary ILP takes the form\cite{Integer-Programming-Book} 
\begin{align*}
    \text{max} \quad &\sum_{i = 1}^m \sum_{j = 1}^n c_{ij} \cdot x_{ij}
    \\
    \text{subject to} \quad &\sum_{j = 1}^n a_{ij} \cdot x_{ij} \leq b \qquad &\text{for} \quad i = 1, \hdots, m
    \\
    &\sum_{i = 1}^m x_{ij} \leq 1 \qquad &\text{for} \quad j = 1, \hdots, n
    \\
    \text{for} \quad &x \in \{0, 1\}^{m \times n},
\end{align*}
where $x$ is the binary decision variable.
\\
This formulation gives way to a Boolean Satisfiability Problem (BSAT), a subfield of CP, which we can attempt to solve with a \textit{satisfiability} (SAT) solver.
\\
\\
As a last remark on the technical implementation aspect, we will quickly address the running time. As exemplified in \autoref{eq:decision-variable-form}, we will have a decision variable for each agent \(a \in [0, M]\), for each day \(i \in [0, T]\), for each task \(j \in [0, N]\). This is a nice representation, but a better and more straightforward definition is that we have a sum of \(N\) tasks over all \(T\) days. That way, we can readily define the total number of decision variables in our boolean formula as \(M \cdot N\) without having to deal with having an unequal amount of tasks for each respective day. As we have stated many times, boolean satisfiability is NP-complete. Therefore, we ultimately end up with a running time of \(2^{M \cdot N}\).
\\
\\
As for The Automated Schedule Validator, as aforementioned, we are convinced that it is technically feasible. Additionally, it would seemingly fit right in with the rest of the suite of disconnected software applications; as such, it seems viable. However, we cannot help but question whether it would be a good solution or if we would just be another in a long line of software implementations that had insisted they keep on their floaties - rather than ever letting them try to swim on their own.